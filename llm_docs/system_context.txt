# YARA Transpilation Guidelines for GoCaaS Signature Inputs

This document describes how to interpret and convert signature entries from unstructured inputs
(like the "Signature Name", "Cleanup Pattern", "Triggers", and "Full Chain" shown below)
into valid YARA rules.

## Structure of the Input

Each signature entry contains the following fields:

1. **Signature Name**  
   - Short identifier for the signature.  
   - Use this as the YARA rule name, converting dots and spaces into underscores.  
   - Example: "backdoor.curl.002" → `rule backdoor_curl_002`.

2. **Cleanup Pattern**  
   - Usually a regex pattern between `~...~` delimiters.  
   - This is the primary detection pattern and often contains escaped sequences.  
   - In YARA, represent this as either:
     - A **regex string** using `/pattern/` syntax if the regex can be directly translated, or
     - A **hex string** (`{ ... }`) if the pattern is binary/hex-based.
   - Preserve all special characters by treating them as raw strings (avoid invalid escape sequences).

3. **Triggers**  
   - A list of simple string indicators that, when found, suggest this signature applies.
   - In YARA, these become `$string_name = "value"` entries.
   - Normalize names for `$string_name` based on the trigger text (e.g., `$trigger_eval`).

4. **Full Chain**  
   - Sequence of indicators that must *all* be present to match the signature.
   - In YARA, these should appear in the `condition` section combined with `and`.
   - If any item in Full Chain overlaps with Triggers, reuse the same string variable.

---

## General Transpilation Process

Given an input signature block:

1. **Start the YARA rule**
   - `rule <normalized_signature_name> {`

2. **Meta Section**
   - Always include:
     - `description` = `<Signature Name>`
     - `author` = `"Automated Transpiler"`
     - `date` = `"<YYYY-MM-DD>"`
   - Include any useful notes in comments if assumptions were made.

3. **Strings Section**
   - For `Cleanup Pattern`:
     - If regex is supported in YARA: `$pattern_main = /<regex>/ nocase`
     - If regex is complex or has non-supported constructs: attempt conversion to hex or simplified regex.
   - For each `Trigger`: `$trigger_<index> = "<trigger_text>"`
   - For each unique `Full Chain` element: `$chain_<index> = "<chain_text>"`

4. **Condition Section**
   - If `Full Chain` is provided:  
     - Condition should require ALL Full Chain elements to match.  
       Example: `$chain_0 and $chain_1`
   - Else if only Triggers are given:
     - Use OR/AND logic as appropriate based on signature intent.
   - Always include `$pattern_main` if Cleanup Pattern exists.

---

YARA Information
rule ExampleRule
{
    strings:
        $my_text_string = "text here"
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
Text strings are enclosed in double quotes just like in the C language. Hex strings are enclosed by curly brackets, and they are composed by a sequence of hexadecimal numbers that can appear contiguously or separated by spaces. Decimal numbers are not allowed in hex strings.

The condition section is where the logic of the rule resides. This section must contain a boolean expression telling under which circumstances a file or process satisfies the rule or not. Generally, the condition will refer to previously defined strings by using their identifiers. In this context the string identifier acts as a boolean variable which evaluate to true if the string was found in the file or process memory, or false if otherwise.

Comments¶
You can add comments to your YARA rules just as if it was a C source file, both single-line and multi-line C-style comments are supported.

/*
    This is a multi-line comment ...
*/

rule CommentExample   // ... and this is single-line comment
{
    condition:
        false  // just a dummy rule, don't do this
}
Strings¶
There are three types of strings in YARA: hexadecimal strings, text strings and regular expressions. Hexadecimal strings are used for defining raw sequences of bytes, while text strings and regular expressions are useful for defining portions of legible text. However text strings and regular expressions can be also used for representing raw bytes by mean of escape sequences as will be shown below.

Hexadecimal strings¶
Hexadecimal strings allow four special constructions that make them more flexible: wild-cards, not operators, jumps, and alternatives. Wild-cards are just placeholders that you can put into the string indicating that some bytes are unknown and they should match anything. The placeholder character is the question mark (?). Here you have an example of a hexadecimal string with wild-cards:

rule WildcardExample
{
    strings:
        $hex_string = { E2 34 ?? C8 A? FB }

    condition:
        $hex_string
}
As shown in the example the wild-cards are nibble-wise, which means that you can define just one nibble of the byte and leave the other unknown.

Starting with version 4.3.0, you may specify that a byte is not a specific value. For that you can use the not operator with a byte value:

rule NotExample
{
    strings:
        $hex_string = { F4 23 ~00 62 B4 }
        $hex_string2 = { F4 23 ~?0 62 B4 }
    condition:
        $hex_string and $hex_string2
}
In the example above we have a byte prefixed with a tilde (~), which is the not operator. This defines that the byte in that location can take any value except the value specified. In this case the first string will only match if the byte is not 00. The not operator can also be used with nibble-wise wild-cards, so the second string will only match if the second nibble is not zero.

Wild-cards and not operators are useful when defining strings whose content can vary but you know the length of the variable chunks, however, this is not always the case. In some circumstances you may need to define strings with chunks of variable content and length. In those situations you can use jumps instead of wild-cards:

rule JumpExample
{
    strings:
        $hex_string = { F4 23 [4-6] 62 B4 }

    condition:
        $hex_string
}
In the example above we have a pair of numbers enclosed in square brackets and separated by a hyphen, that's a jump. This jump is indicating that any arbitrary sequence from 4 to 6 bytes can occupy the position of the jump. Any of the following strings will match the pattern:

F4 23 01 02 03 04 62 B4
F4 23 00 00 00 00 00 62 B4
F4 23 15 82 A3 04 45 22 62 B4
Any jump [X-Y] must meet the condition 0 <= X <= Y. In previous versions of YARA both X and Y must be lower than 256, but starting with YARA 2.0 there is no limit for X and Y.

These are valid jumps:

FE 39 45 [0-8] 89 00
FE 39 45 [23-45] 89 00
FE 39 45 [1000-2000] 89 00
This is invalid:

FE 39 45 [10-7] 89 00
If the lower and higher bounds are equal you can write a single number enclosed in brackets, like this:

FE 39 45 [6] 89 00
The above string is equivalent to both of these:

FE 39 45 [6-6] 89 00
FE 39 45 ?? ?? ?? ?? ?? ?? 89 00
Starting with YARA 2.0 you can also use unbounded jumps:

FE 39 45 [10-] 89 00
FE 39 45 [-] 89 00
The first one means [10-infinite], the second one means [0-infinite].

There are also situations in which you may want to provide different alternatives for a given fragment of your hex string. In those situations you can use a syntax which resembles a regular expression:

rule AlternativesExample1
{
    strings:
        $hex_string = { F4 23 ( 62 B4 | 56 ) 45 }

    condition:
        $hex_string
}
This rule will match any file containing F42362B445 or F4235645.

But more than two alternatives can be also expressed. In fact, there are no limits to the amount of alternative sequences you can provide, and neither to their lengths.

rule AlternativesExample2
{
    strings:
        $hex_string = { F4 23 ( 62 B4 | 56 | 45 ?? 67 ) 45 }

    condition:
        $hex_string
}
As can be seen also in the above example, strings containing wild-cards are allowed as part of alternative sequences.

Text strings¶
As shown in previous sections, text strings are generally defined like this:

rule TextExample
{
    strings:
        $text_string = "foobar"

    condition:
        $text_string
}
This is the simplest case: an ASCII-encoded, case-sensitive string. However, text strings can be accompanied by some useful modifiers that alter the way in which the string will be interpreted. Those modifiers are appended at the end of the string definition separated by spaces, as will be discussed below.

Text strings can also contain the following subset of the escape sequences available in the C language:

\"

Double quote

\\

Backslash

\r

Carriage return

\t

Horizontal tab

\n

New line

\xdd

Any byte in hexadecimal notation

In all versions of YARA before 4.1.0 text strings accepted any kind of unicode characters, regardless of their encoding. Those characters were interpreted by YARA as raw bytes, and therefore the final string was actually determined by the encoding format used by your text editor. This never meant to be a feature, the original intention always was that YARA strings should be ASCII-only and YARA 4.1.0 started to raise warnings about non-ASCII characters in strings. This limitation does not apply to strings in the metadata section or comments. See more details [here](https://github.com/VirusTotal/yara/wiki/Unicode-characters-in-YARA)

Case-insensitive strings¶
Text strings in YARA are case-sensitive by default, however you can turn your string into case-insensitive mode by appending the modifier nocase at the end of the string definition, in the same line:

rule CaseInsensitiveTextExample
{
    strings:
        $text_string = "foobar" nocase

    condition:
        $text_string
}
With the nocase modifier the string foobar will match Foobar, FOOBAR, and fOoBaR. This modifier can be used in conjunction with any modifier, except base64, base64wide and xor.

Wide-character strings¶
The wide modifier can be used to search for strings encoded with two bytes per character, something typical in many executable binaries.

For example, if the string "Borland" appears encoded as two bytes per character (i.e. B\x00o\x00r\x00l\x00a\x00n\x00d\x00), then the following rule will match:

rule WideCharTextExample1
{
    strings:
        $wide_string = "Borland" wide

    condition:
        $wide_string
}
However, keep in mind that this modifier just interleaves the ASCII codes of the characters in the string with zeroes, it does not support truly UTF-16 strings containing non-English characters. If you want to search for strings in both ASCII and wide form, you can use the ascii modifier in conjunction with wide , no matter the order in which they appear.

rule WideCharTextExample2
{
    strings:
        $wide_and_ascii_string = "Borland" wide ascii

    condition:
        $wide_and_ascii_string
}
The ascii modifier can appear alone, without an accompanying wide modifier, but it's not necessary to write it because in absence of wide the string is assumed to be ASCII by default.

XOR strings¶
The xor modifier can be used to search for strings with a single byte XOR applied to them.

The following rule will search for every single byte XOR applied to the string "This program cannot" (including the plaintext string):

rule XorExample1
{
    strings:
        $xor_string = "This program cannot" xor

    condition:
        $xor_string
}
The above rule is logically equivalent to:

rule XorExample2
{
    strings:
        $xor_string_00 = "This program cannot"
        $xor_string_01 = "Uihr!qsnfs`l!b`oonu"
        $xor_string_02 = "Vjkq\"rpmepco\"acllmv"
        // Repeat for every single byte XOR
    condition:
        any of them
}
You can also combine the xor modifier with wide and ascii modifiers. For example, to search for the wide and ascii versions of a string after every single byte XOR has been applied you would use:

rule XorExample3
{
    strings:
        $xor_string = "This program cannot" xor wide ascii
    condition:
        $xor_string
}
The xor modifier is applied after every other modifier. This means that using the xor and wide together results in the XOR applying to the interleaved zero bytes. For example, the following two rules are logically equivalent:

rule XorExample4
{
    strings:
        $xor_string = "This program cannot" xor wide
    condition:
        $xor_string
}

rule XorExample4
{
    strings:
        $xor_string_00 = "T\x00h\x00i\x00s\x00 \x00p\x00r\x00o\x00g\x00r\x00a\x00m\x00 \x00c\x00a\x00n\x00n\x00o\x00t\x00"
        $xor_string_01 = "U\x01i\x01h\x01r\x01!\x01q\x01s\x01n\x01f\x01s\x01`\x01l\x01!\x01b\x01`\x01o\x01o\x01n\x01u\x01"
        $xor_string_02 = "V\x02j\x02k\x02q\x02\"\x02r\x02p\x02m\x02e\x02p\x02c\x02o\x02\"\x02a\x02c\x02l\x02l\x02m\x02v\x02"
        // Repeat for every single byte XOR operation.
    condition:
        any of them
}
Since YARA 3.11, if you want more control over the range of bytes used with the xor modifier use:

rule XorExample5
{
    strings:
        $xor_string = "This program cannot" xor(0x01-0xff)
    condition:
        $xor_string
}
The above example will apply the bytes from 0x01 to 0xff, inclusively, to the string when searching. The general syntax is xor(minimum-maximum).

Base64 strings¶
The base64 modifier can be used to search for strings that have been base64 encoded. A good explanation of the technique is at:

https://www.leeholmes.com/searching-for-content-in-base-64-strings/

The following rule will search for the three base64 permutations of the string "This program cannot":

rule Base64Example1
{
    strings:
        $a = "This program cannot" base64

    condition:
        $a
}
This will cause YARA to search for these three permutations:

VGhpcyBwcm9ncmFtIGNhbm5vd
RoaXMgcHJvZ3JhbSBjYW5ub3
UaGlzIHByb2dyYW0gY2Fubm90
The base64wide modifier works just like the base64 modifier but the results of the base64 modifier are converted to wide.

The interaction between base64 (or base64wide) and wide and ascii is as you might expect. wide and ascii are applied to the string first, and then the base64 and base64wide modifiers are applied. At no point is the plaintext of the ascii or wide versions of the strings included in the search. If you want to also include those you can put them in a secondary string.

The base64 and base64wide modifiers also support a custom alphabet. For example:

rule Base64Example2
{
    strings:
        $a = "This program cannot" base64("!@#$%^&*(){}[].,|ABCDEFGHIJ\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu")

    condition:
        $a
}
The alphabet must be 64 bytes long.

The base64 and base64wide modifiers are only supported with text strings. Using these modifiers with a hexadecimal string or a regular expression will cause a compiler error. Also, the xor, fullword, and nocase modifiers used in combination with base64 or base64wide will cause a compiler error.

Because of the way that YARA strips the leading and trailing characters after base64 encoding, one of the base64 encodings of "Dhis program cannow" and "This program cannot" are identical. Similarly, using the base64 keyword on single ASCII characters is not recommended. For example, "a" with the base64 keyword matches "`", "b", "c", "!", "\xA1", or "\xE1" after base64 encoding, and will not match where the base64 encoding matches the [GWm2][EFGH] regular expression.

Searching for full words¶
Another modifier that can be applied to text strings is fullword. This modifier guarantees that the string will match only if it appears in the file delimited by non-alphanumeric characters. For example the string domain, if defined as fullword, doesn't match www.mydomain.com but it matches www.my-domain.com and www.domain.com.

Regular expressions¶
Regular expressions are one of the most powerful features of YARA. They are defined in the same way as text strings, but enclosed in forward slashes instead of double-quotes, like in the Perl programming language.

rule RegExpExample1
{
    strings:
        $re1 = /md5: [0-9a-fA-F]{32}/
        $re2 = /state: (on|off)/

    condition:
        $re1 and $re2
}
Regular expressions can be also followed by nocase, ascii, wide, and fullword modifiers just like in text strings. The semantics of these modifiers are the same in both cases.

Additionally, they can be followed by the characters i and s just after the closing slash, which is a very common convention for specifying that the regular expression is case-insensitive and that the dot (.) can match new-line characters. For example:

rule RegExpExample2
{
    strings:
        $re1 = /foo/i    // This regexp is case-insentitive
        $re2 = /bar./s   // In this regexp the dot matches everything, including new-line
        $re3 = /baz./is  // Both modifiers can be used together
    condition:
        any of them
}




## Example

**Input:**
Signature Name: backdoor.curl.002  
Cleanup Pattern: ~\{\{\s*var this\.getTem[\w%]+ter\(\)\.add[\w%]+Callback\((system|shell_exec)\)\.[Ff]ilter\([^\)]*\bcurl\$\{IFS%\?\?\}-[^\)]+\.php[^\)]+\)\}\}~  
Triggers: ['AfterFilterCallbac']  
Full Chain: ['AfterFilterCallbac', 'curl${IFS%??}-']

**Output:**
rule backdoor_curl_002 {
    meta:
        description = "backdoor.curl.002"
        author = "Automated Transpiler"
        date = "2025-08-11"
        reference = "Generated from signature database"

    strings:
        $trigger1 = "AfterFilterCallbac"
        $fullchain1 = "AfterFilterCallbac"
        $fullchain2 = "curl${IFS%??}-"
        $pattern = /\{\{\s*var this\.getTem[\w%]+ter\(\)\.add[\w%]+Callback\((system|shell_exec)\)\.[Ff]ilter\([^\)]*\bcurl\$\{IFS%\?\?\}-[^\)]+\.php[^\)]+\)\}\}/

    condition:
        all of ($fullchain*) or any of ($trigger*)
}

Return all formatted YARA rules in JSON format so the response can be easily written to a json file without any further parsing.